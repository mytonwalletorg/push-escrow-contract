;; =============== DESCRIPTION ===============
;;
;; The contract implements a secure escrow payment system allowing for transfers between Telegram users.
;;
;; Flow:
;; 1. The sender creates a "check" with a unique `chat_instance` parameter or `username` and funds it with TON or jetton.
;;    The check is stored in the contract's storage and can be accessed by the receiver.
;; 2. The receiver must cash out the check by providing the same `chat_instance` value or `username`,
;;    signed by Telegram's server to verify their identity.
;; 3. Upon successful verification, the contract transfers the funds to the receiver.
;;    The check is deleted from the contract's storage.
;;
;; Check creation requires fee while cashing is accessible to anyone with a valid signature.
;; 1. op::create_check - only available via internal messages (requires TON to pay for fees)
;; 2. op::cash_check - only available via external messages (allows receivers who don't have TON to claim their funds)
;;
;; Security:
;; - Checks are bound to specific Telegram chats or usernames via the `chat_or_username` parameter.
;; - Requires cryptographic proof (signature) from Telegram to authorize payouts.
;; - The signature includes both the `chat_instance`/`username` and a payload (first 72 bits of sha256 hash of the receiver's address)
;;   ensuring the signature is specific to both the chat/username and the receiving wallet.
;; - Prevents double-spending by immediately deleting the check from the contract's storage.
;;
;; Storage structure:
;; - instance_id:uint32
;; - sudoer:MsgAddress
;; - usdt_jetton_wallet:MsgAddress
;; - my_jetton_wallet:MsgAddress
;; - checks_dict:HashmapE(ID_SIZE, CheckData)
;;
;; CheckData:
;; - amount:int124
;; - is_jetton:int1
;; - jetton_wallet_address:^Cell
;; - is_tiny_jetton:int1
;; - with_username:int1
;; - chat_or_username:^Cell
;; - comment:^Cell
;; - created_at:int32
;; - sender_address:^Cell

#include "imports/stdlib.fc";

int concat_hash(builder b1, builder b2, int n) asm "HASHEXT_SHA256";

;; Operation codes
const int op::jetton_transfer_notification = 0x7362d09c;
const int op::jetton_transfer = 0xf8a7ea5;
const int op::set_acl = 0x996c7334;
const int op::sudoer_request = 0x5e2a5f0a;
const int op::create_check = 0x6a3f7c7f;
const int op::cash_check = 0x69e7ac28;
const int op::cancel_check = 0x4a1c5e3b;

const int ERROR_UNAUTHORIZED_SUDOER = 400;

;; op::create_check error codes
const int ERROR_CHECK_ALREADY_EXISTS = 410;
const int ERROR_INSUFFICIENT_FUNDS = 411;
const int ERROR_INVALID_PAYLOAD = 412;
const int ERROR_INVALID_OP = 413;
const int ERROR_MISSING_FORWARD_PAYLOAD = 414;

;; op::cash_check error codes
const int ERROR_CHECK_NOT_FOUND = 420;
const int ERROR_INVALID_RECEIVER_ADDRESS = 421;
const int ERROR_INCORRECT_SIGNATURE = 422;
const int ERROR_AUTH_DATE_TOO_OLD = 423;
const int ERROR_CHAT_INSTANCE_MISMATCH = 424;
const int ERROR_USERNAME_MISMATCH = 425;
const int ERROR_UNAUTHORIZED_JETTON_WALLET = 426;

;; op::cancel_check error codes
const int ERROR_UNAUTHORIZED_CANCEL = 430;
const int ERROR_INSUFFICIENT_CANCEL_FEE = 431;

const int ID_SIZE = 20;

const int MIN_AMOUNT_TON = 100000000;  ;; 0.1 TON
const int MIN_AMOUNT_USDT = 100000;  ;; 0.1 USDT
const int MIN_AMOUNT_MY = 1000000000;  ;; 1 MY

const int TON_CREATE_GAS_FEE = 6000000;  ;; 0.006 TON
const int TON_CASH_GAS_FEE = 8000000;  ;; 0.008 TON
const int TON_TRANSFER_FEE = 3000000;  ;; 0.003 TON
const int TON_FULL_FEE = TON_CREATE_GAS_FEE + TON_CASH_GAS_FEE + TON_TRANSFER_FEE;
const int TON_CANCEL_FEE = 100000000;  ;; 0.1 TON

const int JETTON_CREATE_GAS_FEE = 7000000;  ;; 0.007 TON
const int JETTON_CASH_GAS_FEE = 9000000;  ;; 0.009 TON
const int JETTON_TRANSFER_FEE = 50000000;  ;; 0.05 TON
const int TINY_JETTON_TRANSFER_FEE = 18000000;  ;; 0.018 TON
const int JETTON_FULL_FEE = JETTON_CREATE_GAS_FEE + JETTON_CASH_GAS_FEE + JETTON_TRANSFER_FEE + TON_TRANSFER_FEE;
const int TINY_JETTON_FULL_FEE = JETTON_CREATE_GAS_FEE + JETTON_CASH_GAS_FEE + TINY_JETTON_TRANSFER_FEE + TON_TRANSFER_FEE;

const int MSG_FLAG_NON_BOUNCEABLE = 0x10;

const slice VERIFICATION_MESSAGE_PREFIX = "5230716013:WebAppData";
const int TELEGRAM_PUBKEY = 0xe7bf03a2fa4602af4580703d88dda5bb59f32ed8b02a56c187fe7d34caed242d;

const slice DEFAULT_COMMENT = "via @push";
const slice CANCEL_COMMENT = "via @push (canceled)";

(int) string_to_int(slice str) inline {
  int result = 0;

  repeat(str.slice_bits() / 8) {
    int char = str~load_uint(8);
    result = (result * 10) + (char - 48);
  }

  return result;
}

(slice) create_verification_message(int check_id, slice auth_date, int with_username, slice chat_or_username, int receiver_address_hash) inline {
  builder part1 = begin_cell()
    .store_slice(VERIFICATION_MESSAGE_PREFIX)
    .store_uint(10, 8).store_slice("auth_date=").store_slice(auth_date)
    .store_uint(10, 8).store_slice("init_data={");

  if (with_username) {
    part1 = part1
      .store_uint(34, 8).store_slice("user").store_uint(34, 8).store_slice(":{")
        .store_uint(34, 8).store_slice("username").store_uint(34, 8).store_slice(":").store_uint(34, 8).store_slice(chat_or_username).store_uint(34, 8)
      .store_slice("}");
  } else {
    part1 = part1
      .store_uint(34, 8).store_slice("chat_instance").store_uint(34, 8).store_slice(":").store_uint(34, 8).store_slice(chat_or_username).store_uint(34, 8);
  }

  builder part2 = begin_cell()
    .store_slice("}")
      .store_uint(10, 8).store_slice("payload=").store_uint(receiver_address_hash, 256);

  int hash = concat_hash(part1, part2, 2);

  return begin_cell().store_uint(hash, 256).end_cell().begin_parse();
}

(cell) create_ton_transfer_message(slice receiver_address, int amount, slice comment) inline {
  builder msg = begin_cell()
    .store_uint(MSG_FLAG_NON_BOUNCEABLE, 6)  ;; bounceable, addr_std
    .store_slice(receiver_address)
    .store_coins(amount)
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1);  ;; use regular internal message header

  if (~ comment.null?()) {
    msg = msg
      .store_uint(0, 32)  ;; text comment opcode
      .store_slice(comment);
  }

  return msg.end_cell();
}

(cell) create_jetton_transfer_message(slice jetton_wallet_address, int is_tiny_jetton, slice receiver_address, int jetton_amount, slice response_address, slice comment) inline {
  builder transfer_payload = begin_cell()
    .store_uint(op::jetton_transfer, 32)
    .store_uint(0, 64)  ;; query_id
    .store_coins(jetton_amount)
    .store_slice(receiver_address)
    .store_slice(response_address)
    .store_uint(0, 1)  ;; custom payload (empty)
    .store_coins(1);  ;; forward amount (1 nanoton for notification)

  if (comment.null?()) {
    transfer_payload = transfer_payload.store_uint(0, 1);  ;; forward payload (empty)
  } else {
    cell forward_payload = begin_cell()
      .store_uint(0, 32)  ;; text comment opcode
      .store_slice(comment)
      .end_cell();

    transfer_payload = transfer_payload
      .store_uint(1, 1)  ;; has forward payload
      .store_ref(forward_payload);
  }

  return begin_cell()
    .store_uint(MSG_FLAG_NON_BOUNCEABLE, 6)
    .store_slice(jetton_wallet_address)
    .store_coins(is_tiny_jetton ? TINY_JETTON_TRANSFER_FEE : JETTON_TRANSFER_FEE)
    .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
    .store_ref(transfer_payload.end_cell())
    .end_cell();
}

(slice) load_sudoer() inline {
  slice ds = get_data().begin_parse();
  ds~load_uint(32);  ;; skip instance_id
  return ds~load_msg_addr();
}

(slice, slice) load_jetton_wallets() inline {
  slice ds = get_data().begin_parse();
  ds~load_uint(32);  ;; skip instance_id
  ds~load_msg_addr();  ;; skip sudoer
  slice usdt_jetton_wallet = ds~load_msg_addr();
  slice my_jetton_wallet = ds~load_msg_addr();
  return (usdt_jetton_wallet, my_jetton_wallet);
}

() save_check(int check_id, slice check_data) impure inline {
  slice ds = get_data().begin_parse();
  int instance_id = ds~load_uint(32);
  slice sudoer = ds~load_msg_addr();
  slice usdt_jetton_wallet = ds~load_msg_addr();
  slice my_jetton_wallet = ds~load_msg_addr();
  cell checks_dict = ds~load_dict();

  checks_dict~udict_set(ID_SIZE, check_id, check_data);

  set_data(begin_cell()
    .store_uint(instance_id, 32)
    .store_slice(sudoer)
    .store_slice(usdt_jetton_wallet)
    .store_slice(my_jetton_wallet)
    .store_dict(checks_dict)
    .end_cell());
}

() delete_check(int check_id) impure inline {
  slice ds = get_data().begin_parse();
  int instance_id = ds~load_uint(32);
  slice sudoer = ds~load_msg_addr();
  slice usdt_jetton_wallet = ds~load_msg_addr();
  slice my_jetton_wallet = ds~load_msg_addr();
  cell checks_dict = ds~load_dict();

  checks_dict~udict_delete?(ID_SIZE, check_id);

  set_data(begin_cell()
    .store_uint(instance_id, 32)
    .store_slice(sudoer)
    .store_slice(usdt_jetton_wallet)
    .store_slice(my_jetton_wallet)
    .store_dict(checks_dict)
    .end_cell());
}

(slice, slice) load_wallet_addresses() inline {
  slice ds = get_data().begin_parse();
  ds~load_uint(32);  ;; skip instance_id
  ds~load_msg_addr();  ;; skip sudoer
  slice usdt_jetton_wallet = ds~load_msg_addr();
  slice my_jetton_wallet = ds~load_msg_addr();

  return (usdt_jetton_wallet, my_jetton_wallet);
}

() save_acl(slice sudoer, slice usdt_jetton_wallet, slice my_jetton_wallet) impure inline {
  slice ds = get_data().begin_parse();
  int instance_id = ds~load_uint(32);
  ds~load_msg_addr();  ;; skip old sudoer
  ds~load_msg_addr();  ;; skip old usdt_jetton_wallet
  ds~load_msg_addr();  ;; skip old my_jetton_wallet
  cell checks_dict = ds~load_dict();

  set_data(begin_cell()
    .store_uint(instance_id, 32)
    .store_slice(sudoer)
    .store_slice(usdt_jetton_wallet)
    .store_slice(my_jetton_wallet)
    .store_dict(checks_dict)
    .end_cell());
}

(int, slice) load_check(int check_id) inline {
  slice ds = get_data().begin_parse();
  ds~load_uint(32);  ;; skip instance_id
  ds~load_msg_addr();  ;; skip sudoer
  ds~load_msg_addr();  ;; skip usdt_jetton_wallet
  ds~load_msg_addr();  ;; skip my_jetton_wallet
  cell checks_dict = ds~load_dict();
  int exists = false;
  slice check_slice = null();
  (check_slice, exists) = checks_dict.udict_get?(ID_SIZE, check_id);
  return (exists, check_slice);
}

(int, int, cell, int, int, cell, cell, int, cell) deserialize_check(slice check_slice) inline {
  int amount = check_slice~load_uint(124);

  ;; Load jetton address (may be null if TON is used)
  int is_jetton = check_slice~load_int(1);
  cell jetton_wallet_address = null();
  int is_tiny_jetton = null();
  if (is_jetton) {
    jetton_wallet_address = check_slice~load_ref();
    is_tiny_jetton = check_slice~load_int(1);
  }

  int with_username = check_slice~load_int(1);
  cell chat_or_username = check_slice~load_ref();
  cell comment = check_slice~load_ref();
  int created_at = check_slice~load_uint(32);
  cell sender_address = check_slice~load_ref();

  return (amount, is_jetton, jetton_wallet_address, is_tiny_jetton, with_username, chat_or_username, comment, created_at, sender_address);
}

(builder) serialize_check(int amount, int is_jetton, cell jetton_wallet_address, int is_tiny_jetton, int with_username, cell chat_or_username, cell comment, int created_at, cell sender_address) inline {
  builder check_data = begin_cell()
    .store_uint(amount, 124)
    .store_int(is_jetton, 1);

  if (is_jetton) {
    check_data = check_data
      .store_ref(jetton_wallet_address)
      .store_int(is_tiny_jetton, 1);
  }

  check_data = check_data
    .store_int(with_username, 1)
    .store_ref(chat_or_username)
    .store_ref(comment)
    .store_uint(created_at, 32)
    .store_ref(sender_address);

  return check_data;
}

() create_check(int check_id, int amount, int min_amount, cell jetton_wallet_address, int is_tiny_jetton, int with_username, cell chat_or_username, slice sender_address, int msg_value, cell comment) impure {
  throw_if(ERROR_INSUFFICIENT_FUNDS, amount < min_amount);

  int is_jetton = ~ jetton_wallet_address.null?();

  int required_value = is_jetton ? (is_tiny_jetton ? TINY_JETTON_FULL_FEE : JETTON_FULL_FEE) : amount + TON_FULL_FEE;
  throw_if(ERROR_INSUFFICIENT_FUNDS, msg_value < required_value);

  (int existing, _) = load_check(check_id);
  throw_if(ERROR_CHECK_ALREADY_EXISTS, existing);

  int created_at = now();
  cell sender_address_cell = begin_cell().store_slice(sender_address).end_cell();

  builder check_data = serialize_check(amount, is_jetton, jetton_wallet_address, is_tiny_jetton, with_username, chat_or_username, comment, created_at, sender_address_cell);
  save_check(check_id, check_data.end_cell().begin_parse());
}

() validate_cash_check(
  int check_id, int is_jetton, int is_tiny_jetton, int amount, int with_username, cell stored_chat_or_username, int created_at, cell auth_date, cell chat_or_username, slice receiver_address, slice signature
) impure inline {
  int addr_type = receiver_address.preload_uint(2);
  throw_if(ERROR_INVALID_RECEIVER_ADDRESS, addr_type != 2);

  (int workchain_id, int receiver_address_hash) = receiver_address.parse_std_addr();
  throw_if(ERROR_INVALID_RECEIVER_ADDRESS, workchain_id != 0);

  slice chat_or_username_slice = chat_or_username.begin_parse();
  slice auth_date_slice = auth_date.begin_parse();

  slice message = create_verification_message(check_id, auth_date_slice, with_username, chat_or_username_slice, receiver_address_hash);
  int is_valid = check_data_signature(message, signature, TELEGRAM_PUBKEY);
  throw_if(ERROR_INCORRECT_SIGNATURE, ~ is_valid);

  int auth_date_int = string_to_int(auth_date_slice);
  throw_if(ERROR_AUTH_DATE_TOO_OLD, auth_date_int < created_at);

  slice stored_chat_or_username_slice = stored_chat_or_username.begin_parse();
  throw_if(
    with_username ? ERROR_USERNAME_MISMATCH : ERROR_CHAT_INSTANCE_MISMATCH,
    ~ equal_slices_bits(chat_or_username_slice, stored_chat_or_username_slice)
  );
}

() recv_external(slice in_msg) impure {
  int op = in_msg~load_uint(32);

  if (op == op::cash_check) {
    int check_id = in_msg~load_uint(ID_SIZE);

    cell auth_date = in_msg~load_ref();
    cell chat_or_username = in_msg~load_ref();
    slice receiver_address = in_msg~load_msg_addr();
    slice signature = in_msg~load_bits(512);  ;; Ed25519 signature

    (int exists, slice check_slice) = load_check(check_id);
    throw_if(ERROR_CHECK_NOT_FOUND, ~ exists);

    (int amount, int is_jetton, cell jetton_wallet_address, int is_tiny_jetton, int with_username, cell stored_chat_or_username, cell comment, int created_at, cell sender_address) = deserialize_check(check_slice);

    validate_cash_check(
      check_id, is_jetton, is_tiny_jetton, amount, with_username, stored_chat_or_username, created_at, auth_date, chat_or_username, receiver_address, signature
    );

    slice comment_slice = comment.begin_parse();
    slice final_comment = comment_slice.slice_bits() > 0 ? comment_slice : DEFAULT_COMMENT;

    accept_message();

    delete_check(check_id);

    if (~ is_jetton) {
      cell msg = create_ton_transfer_message(receiver_address, amount, final_comment);
      send_raw_message(msg, SEND_MODE_PAY_FEES_SEPARATELY + SEND_MODE_IGNORE_ERRORS);
    } else {
      slice jetton_wallet_address_slice = jetton_wallet_address.begin_parse();
      cell msg = create_jetton_transfer_message(jetton_wallet_address_slice, is_tiny_jetton, receiver_address, amount, my_address(), final_comment);
      send_raw_message(msg, SEND_MODE_PAY_FEES_SEPARATELY + SEND_MODE_IGNORE_ERRORS);
    }

    return ();
  }

  ;; Operation not supported
  throw(0xffff);
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
  if (in_msg_body.slice_empty?()) {
    return ();
  }

  slice msg_header_slice = in_msg_full.begin_parse();
  int flags = msg_header_slice~load_uint(4);

  ;; Ignore bounced messages
  if (flags & 1) {
    return ();
  }

  slice sender_address = msg_header_slice~load_msg_addr();
  int op = in_msg_body~load_uint(32);

  if (op == op::set_acl) {
    slice sudoer = load_sudoer();
    throw_if(ERROR_UNAUTHORIZED_SUDOER, ~ equal_slices_bits(sender_address, sudoer));

    slice new_sudoer = in_msg_body~load_msg_addr();
    slice new_usdt_jetton_wallet = in_msg_body~load_msg_addr();
    slice new_my_jetton_wallet = in_msg_body~load_msg_addr();

    save_acl(new_sudoer, new_usdt_jetton_wallet, new_my_jetton_wallet);

    return ();
  }

  if (op == op::sudoer_request) {
    slice sudoer = load_sudoer();
    throw_if(ERROR_UNAUTHORIZED_SUDOER, ~ equal_slices_bits(sender_address, sudoer));

    cell message = in_msg_body~load_ref();
    int mode = in_msg_body~load_uint(8);

    send_raw_message(message, mode);

    return ();
  }

  if (op == op::create_check) {
    throw_if(ERROR_INVALID_PAYLOAD, in_msg_full.cell_depth() > 3);

    int check_id = in_msg_body~load_uint(ID_SIZE);
    int amount = msg_value - TON_FULL_FEE;
    int with_username = in_msg_body~load_int(1);
    cell chat_or_username = in_msg_body~load_ref();
    cell comment = in_msg_body~load_ref();

    create_check(check_id, amount, MIN_AMOUNT_TON, null(), null(), with_username, chat_or_username, sender_address, msg_value, comment);

    return ();
  }

  if (op == op::jetton_transfer_notification) {
    (slice usdt_jetton_wallet, slice my_jetton_wallet) = load_wallet_addresses();

    ;; Check if sender is one of the authorized jetton wallets
    int is_usdt_wallet = equal_slices_bits(sender_address, usdt_jetton_wallet);
    int is_my_wallet = equal_slices_bits(sender_address, my_jetton_wallet);
    throw_if(ERROR_UNAUTHORIZED_JETTON_WALLET, ~ (is_usdt_wallet | is_my_wallet));

    int query_id = in_msg_body~load_uint(64);
    int jetton_amount = in_msg_body~load_coins();
    slice original_sender = in_msg_body~load_msg_addr();

    throw_if(ERROR_MISSING_FORWARD_PAYLOAD, in_msg_body.slice_refs() == 0);

    cell forward_cell = in_msg_body~load_ref();
    throw_if(ERROR_INVALID_PAYLOAD, forward_cell.cell_depth() > 3);

    slice forward_payload = forward_cell.begin_parse();
    int forward_op = forward_payload~load_uint(32);
    throw_if(ERROR_INVALID_OP, forward_op != op::create_check);

    int check_id = forward_payload~load_uint(ID_SIZE);
    int with_username = forward_payload~load_int(1);
    cell chat_or_username = forward_payload~load_ref();
    cell comment = forward_payload~load_ref();

    cell jetton_wallet_address_cell = begin_cell().store_slice(sender_address).end_cell();
    int is_tiny_jetton = is_usdt_wallet;

    try {
      int min_amount = is_usdt_wallet ? MIN_AMOUNT_USDT : MIN_AMOUNT_MY;
      create_check(check_id, jetton_amount, min_amount, jetton_wallet_address_cell, is_tiny_jetton, with_username, chat_or_username, original_sender, msg_value, comment);
    } catch (_, err) {
      if (err == ERROR_CHECK_ALREADY_EXISTS) {
        cell msg = create_jetton_transfer_message(sender_address, is_tiny_jetton, original_sender, jetton_amount, original_sender, CANCEL_COMMENT);
        send_raw_message(msg, SEND_MODE_PAY_FEES_SEPARATELY + SEND_MODE_IGNORE_ERRORS);
      } else {
        throw err;
      }
    }

    return ();
  }

  if (op == op::cancel_check) {
    throw_if(ERROR_INSUFFICIENT_CANCEL_FEE, msg_value < TON_CANCEL_FEE);

    int check_id = in_msg_body~load_uint(ID_SIZE);

    (int exists, slice check_slice) = load_check(check_id);
    throw_if(ERROR_CHECK_NOT_FOUND, ~ exists);

    (int amount, int is_jetton, cell jetton_wallet_address, int is_tiny_jetton, _, _, _, _, cell stored_sender_address) = deserialize_check(check_slice);

    throw_if(ERROR_UNAUTHORIZED_CANCEL, ~ equal_slices_bits(sender_address, stored_sender_address.begin_parse()));

    delete_check(check_id);

    if (~ is_jetton) {
      ;; TON refund
      cell msg = create_ton_transfer_message(sender_address, amount, CANCEL_COMMENT);
      send_raw_message(msg, SEND_MODE_PAY_FEES_SEPARATELY + SEND_MODE_IGNORE_ERRORS);
    } else {
      ;; Jetton refund
      slice jetton_wallet_address_slice = jetton_wallet_address.begin_parse();
      cell msg = create_jetton_transfer_message(jetton_wallet_address_slice, is_tiny_jetton, sender_address, amount, sender_address, CANCEL_COMMENT);
      send_raw_message(msg, SEND_MODE_PAY_FEES_SEPARATELY + SEND_MODE_IGNORE_ERRORS);
    }

    return ();
  }
}

;; Get method to retrieve check information
;; @param check_id ID of the check to retrieve
;; @returns (amount, jetton_wallet_address_cell, with_username, chat_or_username, comment_cell, created_at, sender_address)
(int, cell, int, cell, cell, int, cell) get_check_info(int check_id) method_id {
  (int exists, slice check_slice) = load_check(check_id);
  throw_if(ERROR_CHECK_NOT_FOUND, ~ exists);

  (int amount, _, cell jetton_wallet_address_cell, _, int with_username, cell chat_or_username, cell comment, int created_at, cell sender_address) = deserialize_check(check_slice);

  return (amount, jetton_wallet_address_cell, with_username, chat_or_username, comment, created_at, sender_address);
}
